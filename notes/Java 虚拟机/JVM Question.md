## 运行时数据区域和垃圾回收

#### 1. JVM运行的数据区域有哪些，作用分别是什么？

> 参考以下要点回答：
>
> 程序计数器、虚拟机栈、本地方法栈、堆内存、方法区（包括静态常量池）、直接内存区。



#### 2. 垃圾收集机制主要管理的区域是哪个？为什么别的区域不需要或不经常需要回收？

> 参考以下要点回答：
>
> 主要管理堆内存，分析为什么虚拟机栈和本地方法栈、方法区、直接内存区不需要经常回收。



#### 3. 如果你的程序报了 OutOfMemoryError 异常，你会如何查找问题？

> 参考以下要点回答：
>
> 

#### 4. Java 垃圾回收机制如何判断对象当前是否需要回收？

> 参考以下要点回答：
>
> 



#### 5. 垃圾收集算法中，标记-清除法、复制算法和标记-整理法，分别有什么优劣？

> 参考以下要点回答：
>
> 描述这三种算法的收集过程，分别分析优劣。



#### 6. 描述分代收集算法的过程，为什么年轻代区域比例默认为 8:1:1，为什么需要区分年轻年老代？

> 参考以下要点回答：
>
> - 描述分代收集算法的过程。
> - 年轻代区域比例为 8:1:1 原因：1、大部分对象朝生夕死，所以surviver区相对于eden区小。2、两个 surviver区让对象不会那么快进入老年代，而是有个来回复制的过程。
> - 区分年轻年老代：一般来说，年轻代用复制算法，年老代用标记-整理法。年轻代对象的特点是朝生夕死，复制算法效率较高。年老代算法一般能长期存活，不适合在年轻代来回复制。



#### *7. GC 操作的某些阶段（如可达性分析遍历根节点），不可以出现引用关系不断变化的情况，JVM如何保证这一点。

> 参考以下要点回答：
>
> 



#### *8. JVM 提供了多种垃圾收集器，在选择的时候，你会考虑什么因素？

> 参考以下要点回答：
>
> 



#### 9. 你会用什么工具监控 JVM，监控哪些参数？

> 参考以下要点回答：
>
> 



#### 10. 对象如何晋升到老年代？

对象优先在新生代的 `eden` 区分配内存，但是也并不绝对，下面几种情况对象会晋升到老年代

- 大对象直接进入老年代。比如很长的字符串，或者很大的数组等
- 长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中（Header）包含了 GC 分代年龄标记信息。如果对象在 `eden` 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增加 1 岁。当它的年龄到达一定的数值时（jdk1.7 默认是 15 岁），就会晋升到老年代中。
- 动态对象年龄判定。当 `Survivor` 空间中相同年龄所有对象的大小总和大于 `Survivor` 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。



#### 11. 分别写出堆内存溢出与栈内存溢出的程序？

这里涉及到[Java运行时数据区域](https://blog.csdn.net/codejas/article/details/78635641)方面的知识。

栈内存溢出

```java
    public void f() {
        f();
    }
```

堆内存溢出

```java
    public void testd() {
        List<String> list = new ArrayList<>();
        int i = 0;

        while (true) {
            list.add(new String(i + ""));
            i++;
        }
    }
```




#### 12. 说说强引用、软引用、弱引用、虚引用以及他们之间和gc的关系

- 强引用是指在代码中普遍存在的，类似 `Object obj = new Object()；` **这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉引用的对象**
- 软引用是用来描述一些还有用但并非是必要的对象。对于软引用着的对象，**在系统将要发生内存溢出异常之前，将会把这类对象列进回收范围进行第二次的回收。**如果这次回收仍然没有足够的内存，就会抛出内存溢出异常。在jdk1.2 中提供了SoftReference 类来实现软引用
- 弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次的垃圾回收之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在jdk1.2 中提供了WeakReference 类来实现弱引用
- 虚引用也被称为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象的实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集时收到一个系统通知**。在jdk1.2 中提供了PhantomReference 类来实现虚引用。



## 类加载

#### 1. 简述 java 类加载机制 ?

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。



#### 2. 简述虚拟机类加载的过程？

- 加载：加载 class 的二进制流，将字节流存储结构转化为方法区运行的数据结构，生成一个 `Class` 对象作为这个类的访问入口
- 验证：保证 class 文件的字节流中包含的信息符合虚拟机的要求，比如文件格式验证，元数据验证等
- 准备：为类变量分配内存，并设置初始值，并非在堆中分配内存，而是在方法区
- 解析：将常量池中的符号引用替换为直接引用
- 初始化：也是类加载的最后一步，执行类构造器 `clinit()` 方法，按照要求初始化静态变量的值，并执行静态代码块

类加载的流程图如下：

![类加载过程.png](https://upload-images.jianshu.io/upload_images/1341067-251b433b93bf6dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





#### 3. 反射中，`Class.forName()` 和 `ClassLoader.loadClass()` 区别

- `Class.forName()` 默认执行类加载过程中的连接与初始化动作，一旦执行初始化动作，静态变量就会被初始化为程序员设置的值，如果有静态代码块，静态代码块也会被执行
- `ClassLoader.loadClass()` 默认只执行类加载过程中的加载动作，后面的动作都不会执行




#### 4. 什么是类加载器，类加载器有哪些 ?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有以下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。




#### 5. 类加载器双亲委派模型机制？

类加载器的双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种加载器方式。上面类加载器的父子关系一般不会以继承的方式实现，而是采用组合的关系来复用父类加载器的代码。

工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器，只有当父加载器无法完成这个加载请求时，子加载器才会尝试自己去加载。

为什么要有双亲委派模型呢？原因是双亲委派模型可以保证 Java 程序的稳定性。比如你有一个类，在不采用双亲委派模型的情况下，可能会有不同的加载器去加载这个类，不同类加载器加载出来的 `Class` 文件必然不相同，这样就造成了不一致性。



![类加载器.png](https://upload-images.jianshu.io/upload_images/1341067-dd6493c140180fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

